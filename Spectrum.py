#!/usr/bin/python
from __future__ import print_function, division
import numpy as np
# Spectrum Class

# Begun August 2016
# Jason Neal


class Spectrum(object):
    """ Spectrum class represents and manipulates astronomical spectra. """
    
    def __init__(self, flux=[], xaxis=[], header=None, calibrated=False):
        """ Initalise a Spectrum object """
        self.xaxis = np.asarray(xaxis)
        self.flux = np.asarray(flux)
        self.calibrated = calibrated
        # Astropy Header object or a python dictionary 
        # Acess with a dictionary call.
        self.header = header    

    def wav_select(self, wav_min, wav_max):
        """ Fast Wavelength selector between wav_min and wav_max values 
        If passed lists it will return lists.
        If passed np arrays it will return arrays
    
        """
        x_org = self.xaxis
        flux_org = self.flux
        if len(self.xaxis) == 0:
            print("No xaxis to select from")
        else:
            try:
                mask = (self.xaxis > wav_min) & (self.xaxis < wav_max)
                self.xaxis = self.xaxis[mask]
                self.flux = self.flux[mask]
            except TypeError:
                print("Make sure your xaxis is an array")
                #Return to original values
                self.xaxis = x_org
                self.flux = flux_org
                raise


    def doppler_shift(self, RV):
        ''' Function to compute a wavelenght shift due to radial velocity
        using RV / c = delta_lambda/lambda
        RV - radial velocity (in km/s)
        lambda_rest - rest wavelenght of the spectral line
        delta_lambda - (lambda_final - lambda_rest)
        '''
        if abs(RV) < 1e-7:
            """ RV smaller then 0.1 mm/s"""
            print("Warning the RV value given is very small (<0.1 mm/s).\n " 
                  "Not performing the doppler shift")

        elif np.isnan(RV) or np.isinf(RV):
            print("Warning RV is infinity or Nan. "
                  "Not performing the doppler shift")

        elif self.calibrated:
            c = 299792.458
            lambdaShift = self.xaxis * (RV / c)
            self.xaxis = self.xaxis + lambdaShift
        else:
            print("Attribute xaxis is not wavelength calibrated. Cannot perform doppler shift")


    def calibrate_with(self, wl_map):
        """ Calibrate with polynomial with parameters wl_map.
        Input:
            wl_map - Polynomial cooeficients that take the form expected by np.poylval()
        Output:
            self.xaxis is replaced with the calibrated spectrum
            self.calibrated is set to True
        The parameters can be generated by np.polyfit(x, y, order)
        """
        if self.calibrated:
            print("Spectrum already calibrated, Not Calibrating again.")
        else:
            wavelength = np.polyval(wl_map, self.xaxis)   # Polynomail parameters
            self.xaxis = wavelength
            self.calibrated = True  # Set calibrated Flag 
        
        if np.any(self.xaxis <= 0):
            print("Warning! The wavlength solution contains a value of zero. "
                  "Please check your calibrations\nThis will not doppler "
                  "shift correctly. This may raise an error in the future.")


    def interpolate_to(self, spectrum):
        """Interpolate wavelength solution to wavelength of spectrum
        Think about weather this should be spectrum or sepctrum.xaxis (just the wavelength) 
        
        A comment from ENAA 2016 regarded interpolation. 
        Interpolation techniques need to be tested to acheive best
        performance for low signal applications. i.e. direct exoplanet detection"""
        pass



## TO DO !
#--------------------
# Overrideopperators such 
# e.g, plus, minus, subtract, divide

# Interpolation in wavelength (before subtraction)
